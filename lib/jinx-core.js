// Generated by CoffeeScript 1.9.3
(function() {
  var fs, inDevMode, jextensions, jinxCommands, jinxConfig, jinxUserparams, jshell;

  inDevMode = true;

  jinxUserparams = ['nodejs', 'jinx'];

  jinxConfig = require('./config/jinx-config.json');

  jinxCommands = require('./config/jinx-commands.json');

  fs = require('fs');

  jextensions = require('./jinx-ext');

  jshell = require('child_process').exec;

  module.exports = {
    jout: function(message) {
      if (jinxConfig["default"].debug) {
        return console.log("" + message);
      }
    },
    jerr: function(message) {
      if (jinxConfig["default"].errors) {
        return console.log("" + message);
      }
    },
    jdbg: function(message) {
      return console.log("" + message);
    },
    exists: function(path) {
      var e, file;
      try {
        file = fs.openSync(path, 'r');
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    cp: function(source, target) {
      var e;
      try {
        fs.writeFileSync("" + target, fs.readFileSync("" + source));
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    mkdir: function(path, root) {
      var e, folder, folders;
      folders = path.split('/');
      folder = folders.shift();
      root = (root || '') + folder + '/';
      try {
        fs.mkdirSync(root);
      } catch (_error) {
        e = _error;
        if (!fs.statSync(root).isDirectory()) {
          throw new Error(e);
        }
      }
      return !folders.length || this.mkdir(folders.join('/'), root);
    },
    jshell: function(command) {
      return jshell(command);
    },
    cwd: function() {
      return "" + (process.cwd());
    },
    usage: function() {
      return this.jout("usage: jinx <generate|destroy> <recipe> <custom name> <target>");
    },
    version: function() {
      return "" + jinxConfig["default"].version;
    },
    start: function(args) {
      var arg, i, len;
      if ((args != null)) {
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          jinxUserparams.push(arg);
        }
      } else {
        this.usage();
      }
      return true;
    },
    reset: function() {
      return jinxUserparams = ['nodejs', 'jinx'];
    },
    preprocess: function() {
      var JinxCustomName, JinxOptions, JinxRecipe, JinxTarget, JinxTask, userparams;
      userparams = [];
      if (inDevMode) {
        userparams = jinxUserparams;
      } else {
        userparams = process.argv;
      }
      if (userparams.length <= 4) {
        this.jout("error: not enough arguments.");
        this.usage();
      } else {
        JinxTask = userparams[2];
        JinxRecipe = userparams[3];
        JinxCustomName = userparams[4];
        if (userparams[5] != null) {
          JinxTarget = userparams[5];
        } else {
          JinxTarget = "";
        }
        if (userparams[6] != null) {
          JinxOptions = userparams[6];
        } else {
          JinxOptions = "";
        }
      }
      return true;
    },
    validate: function() {
      var code, generator, isValidGenerator, isValidRecipe, isValidTask, recipe, ref, ref1, ref2, task;
      isValidGenerator = false;
      isValidRecipe = false;
      isValidTask = false;
      ref = jinxCommands.generators;
      for (generator in ref) {
        code = ref[generator];
        if (generator === jinxUserparams[2]) {
          isValidGenerator = true;
        }
      }
      ref1 = jinxCommands.recipes;
      for (recipe in ref1) {
        code = ref1[recipe];
        if (recipe === jinxUserparams[3]) {
          isValidRecipe = true;
        }
      }
      ref2 = jinxCommands.tasks;
      for (task in ref2) {
        code = ref2[task];
        if (task === jinxUserparams[2]) {
          isValidTask = true;
        }
      }
      if (isValidGenerator) {
        if (isValidRecipe) {
          return true;
        } else {
          this.jout("the argument " + jinxUserparams[3] + " is not a valid recipe. ");
          this.usage();
          return false;
        }
      } else {
        if (isValidTask) {
          return true;
        } else {
          this.jout("the argument " + jinxUserparams[2] + " is not a valid command.");
          this.usage();
          return false;
        }
      }
    },
    execute: function(commands) {
      return true;
    },
    checkForMeteor: function() {
      return true;
    },
    checkForJinx: function() {
      return true;
    },
    createJinxMeteorWorkspace: function(options) {
      return true;
    },
    jcheckForMeteor: function() {
      var status;
      status = this.exists('.meteor/versions');
      return status;
    },
    jcheckForJinx: function() {
      var status;
      status = this.exists('.jinx/versions');
      return status;
    },
    jgenerateWorkspace: function(workspace) {
      var i, len, ref, structureItem;
      this.jout("Creating " + workspace.name + "...");
      ref = workspace.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        structureItem = ref[i];
        this.jout(structureItem);
        this.mkdir("" + structureItem);
      }
      this.mkdir(".jinx");
      return this.cp("core/versions", ".jinx/versions");
    },
    jloadStructure: function(structureId) {
      var e, jstruct;
      try {
        jstruct = require('./structures/' + structureId + '.json');
      } catch (_error) {
        e = _error;
      }
      return jstruct;
    },
    jgenerateDefaultFiles: function(workspace) {
      var ref, results, source, target;
      fs = require('fs');
      ref = workspace.files;
      results = [];
      for (source in ref) {
        target = ref[source];
        this.jout(target + " from lib/recipes/" + source);
        results.push(fs.writeFileSync("" + target, fs.readFileSync("lib/recipes/" + source)));
      }
      return results;
    },
    jMeteorCreate: function(projectfolder) {
      return this.jshell("meteor create " + projectfolder);
    },
    jinxMain: function(args) {
      if (args != null) {
        switch (args[0]) {
          case 'new':
            if (/-/i.test(args[1])) {
              switch (args[1]) {
                case '-sm':
                  this.jout("selected small.");
                  break;
                default:
                  this.jout("selection unavailable.");
              }
            } else {
              this.jout("selection unavailable.");
            }
            break;
          default:
            this.jout("Wrong arguments");
        }
      } else {
        this.jout("Not enough arguments");
      }
    }
  };

}).call(this);
