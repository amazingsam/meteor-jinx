// Generated by CoffeeScript 1.9.3
(function() {
  var Q, fs, inDevMode, jextensions, jinxCommands, jinxConfig, jinxUserparams, jshell;

  inDevMode = true;

  jinxUserparams = ['nodejs', 'jinx'];

  jinxConfig = require('./config/jinx-config.json');

  jinxCommands = require('./config/jinx-commands.json');

  fs = require('fs');

  jextensions = require('./jinx-ext');

  Q = require('q');

  jshell = require('child_process').exec;

  module.exports = {
    jout: function(message) {
      if (jinxConfig["default"].debug) {
        return console.log("" + message);
      }
    },
    jerr: function(message) {
      if (jinxConfig["default"].errors) {
        return console.log("" + message);
      }
    },
    jdbg: function(message) {
      return console.log("" + message);
    },
    exists: function(path) {
      var e, file;
      try {
        file = fs.openSync(path, 'r');
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    writefile: function(path, data) {
      var e, file;
      try {
        file = fs.openSync(path, 'w');
        fs.writeSync(file, data);
        fs.closeSync(file);
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    cp: function(source, target) {
      var e;
      try {
        fs.writeFileSync("" + target, fs.readFileSync("" + source));
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    mkdir: function(path, root) {
      var e, folder, folders;
      folders = path.split('/');
      folder = folders.shift();
      root = (root || '') + folder + '/';
      try {
        fs.mkdirSync(root);
      } catch (_error) {
        e = _error;
        if (!fs.statSync(root).isDirectory()) {
          throw new Error(e);
        }
      }
      return !folders.length || this.mkdir(folders.join('/'), root);
    },
    usage: function() {
      return this.jout("usage: jinx <task|generator> <recipe> <identifier> <target>");
    },
    version: function() {
      return "" + jinxConfig["default"].version;
    },
    main: function() {
      inDevMode = false;
      this.preprocess();
      this.validate();
      return this.execute();
    },
    start: function(args) {
      var arg, i, len;
      if ((args != null)) {
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          jinxUserparams.push(arg);
        }
      } else {
        this.usage();
      }
      return true;
    },
    reset: function() {
      return jinxUserparams = ['nodejs', 'jinx'];
    },
    preprocess: function() {
      var JinxCustomName, JinxOptions, JinxRecipe, JinxTarget, JinxTask, userparams;
      userparams = [];
      if (inDevMode) {
        userparams = jinxUserparams;
      } else {
        userparams = process.argv;
        jinxUserparams = userparams;
      }
      if (userparams.length <= 4) {
        this.jout("error: not enough arguments.");
        this.usage();
        process.exit();
      } else {
        JinxTask = userparams[2];
        JinxRecipe = userparams[3];
        JinxCustomName = userparams[4];
        if (userparams[5] != null) {
          JinxTarget = userparams[5];
        } else {
          JinxTarget = "";
        }
        if (userparams[6] != null) {
          JinxOptions = userparams[6];
        } else {
          JinxOptions = "";
        }
      }
      return true;
    },
    validate: function() {
      var code, generator, isValidGenerator, isValidRecipe, isValidTask, recipe, ref, ref1, ref2, task;
      isValidGenerator = false;
      isValidRecipe = false;
      isValidTask = false;
      ref = jinxCommands.generators;
      for (generator in ref) {
        code = ref[generator];
        if (generator === jinxUserparams[2]) {
          isValidGenerator = true;
        }
      }
      ref1 = jinxCommands.recipes;
      for (recipe in ref1) {
        code = ref1[recipe];
        if (recipe === jinxUserparams[3]) {
          isValidRecipe = true;
        }
      }
      ref2 = jinxCommands.tasks;
      for (task in ref2) {
        code = ref2[task];
        if (task === jinxUserparams[2]) {
          isValidTask = true;
        }
      }
      if (isValidGenerator) {
        if (isValidRecipe) {
          return true;
        } else {
          this.jout("the argument " + jinxUserparams[3] + " is not a valid recipe. ");
          this.usage();
          return false;
        }
      } else {
        if (isValidTask) {
          if (isValidRecipe) {
            return true;
          } else {
            this.jout("the argument " + jinxUserparams[3] + " is not a valid recipe. ");
            this.usage();
            return false;
          }
        } else {
          this.jout("the argument " + jinxUserparams[2] + " is not a valid command.");
          this.usage();
          return false;
        }
      }
    },
    execute: function() {
      var gcode, generator, options, rcode, recipe, ref, ref1, ref2, runGenerator, runTask, task, tcode;
      runGenerator = false;
      runTask = false;
      options = {};
      ref = jinxCommands.tasks;
      for (task in ref) {
        tcode = ref[task];
        if (task === jinxUserparams[2]) {
          options['task'] = tcode;
          runTask = true;
        }
      }
      ref1 = jinxCommands.generators;
      for (generator in ref1) {
        gcode = ref1[generator];
        if (generator === jinxUserparams[2]) {
          options['generator'] = gcode;
          runGenerator = true;
        }
      }
      ref2 = jinxCommands.recipes;
      for (recipe in ref2) {
        rcode = ref2[recipe];
        if (recipe === jinxUserparams[3]) {
          options['recipe'] = rcode;
        }
      }
      if (runGenerator) {
        this.executeGenerator(options);
      }
      if (runTask) {
        this.executeTask(options);
      }
      return true;
    },
    parseRecipe: function(pocket) {
      var jData, jIdentifier, jRecipe, tmpl;
      jIdentifier = jinxUserparams[4];
      jRecipe = jinxUserparams[3];
      jData = jinxUserparams[6];
      if (pocket['generate'] != null) {
        switch (pocket['code']) {
          case 500:
            tmpl = jextensions.createBlazeTemplate({
              'name': jIdentifier
            });
        }
      }
      if (pocket['destroy'] != null) {
        switch (pocket['code']) {
          case 500:
            this.jout("TODO: undo");
        }
      }
      if (pocket['create'] != null) {
        switch (pocket['code']) {
          case 1:
            if (this.checkForMeteor()) {
              this.jout("Detected Meteor, Jinx will not run a new Meteor task.");
            } else {
              this.jout("Running Meteor tasks... " + jIdentifier);
              this.createMeteorProject({
                'structureId': jRecipe,
                'target': jIdentifier
              });
              this.createJinxMeteorWorkspace({
                'structureId': jRecipe,
                'target': jIdentifier
              });
            }
            break;
          case 4001:
            if (this.checkForMeteor()) {
              this.jout("Detected Meteor, Jinx will not run a new Meteor task.");
            } else {
              this.jout("Running Meteor tasks...");
              createMeteorProject({
                'target': jIdentifier
              });
            }
            if (this.checkForJinx()) {
              this.jout("Jinx already exists!");
            } else {
              createJinxMeteorWorkspace({
                'structureId': jRecipe,
                'target': jIdentifier
              });
            }
            break;
          default:
            this.jout("error: invalid recipe");
        }
      }
      if (pocket['remove'] != null) {
        switch (pocket['code']) {
          case 4001:
            return this.jout("TODO: undo");
        }
      }
    },
    executeGenerator: function(options) {
      var pocket;
      pocket = {};
      switch (options['generator']) {
        case 100:
          pocket["generate"] = true;
          pocket["code"] = options['recipe'];
          break;
        case 200:
          pocket["destroy"] = true;
          pocket["code"] = options['recipe'];
      }
      this.parseRecipe(pocket);
      return true;
    },
    executeTask: function(options) {
      var pocket;
      pocket = {};
      switch (options['task']) {
        case 5000:
          pocket["create"] = true;
          pocket["code"] = options['recipe'];
          break;
        case 6000:
          pocket["remove"] = true;
          pocket["code"] = options['recipe'];
      }
      this.parseRecipe(pocket);
      return true;
    },
    checkForMeteor: function() {
      var status;
      status = this.exists(".meteor/versions");
      return status;
    },
    checkForJinx: function() {
      var status;
      status = this.exists(".jinx/versions");
      return status;
    },
    createJinxMeteorWorkspace: function(options) {
      var folder, i, len, ref, ref1, results, source, target, targetfolder, workspace;
      targetfolder = "";
      if ((options['target'] != null)) {
        targetfolder = options['target'];
        if (options['target'] === ".") {
          targetfolder = "./";
        } else {
          targetfolder += "/";
        }
      } else {
        targetfolder = "./";
      }
      workspace = this.loadStructure(options['structureId']);
      this.mkdir(targetfolder + ".jinx");
      this.cp("lib/recipes/core/versions", targetfolder + ".jinx/versions");
      this.cp("lib/structures/" + options['structureId'] + ".json", targetfolder + ".jinx/structure.json");
      ref = workspace.folders;
      for (i = 0, len = ref.length; i < len; i++) {
        folder = ref[i];
        this.mkdir("" + targetfolder + folder);
      }
      ref1 = workspace.files;
      results = [];
      for (source in ref1) {
        target = ref1[source];
        results.push(this.cp("lib/recipes/" + source, "" + targetfolder + target));
      }
      return results;
    },
    createMeteorProject: function(options) {
      var meteortask;
      meteortask = "meteor create " + ("" + options['target']);
      this.jout("MT: " + meteortask);
      return jshell(meteortask, function(error, stdout, stderr) {
        console.log('stdout: ' + stdout);
        console.log('stderr: ' + stderr);
        if (error !== null) {
          console.log('exec error: ' + error);
        }
      });
    },
    loadStructure: function(structureId) {
      var e, myStructure;
      try {
        myStructure = require('./structures/' + structureId + '.json');
      } catch (_error) {
        e = _error;
      }
      return myStructure;
    }
  };

}).call(this);
